# Copyright (C) 2017 Jente Hidskes <hjdskes@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import sys

import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gdk, GObject, Gtk


# TODO: this file needs to be checked for its Wayland support.
class KeyStroke(GObject.Object):
    """The KeyStroke object represents a keyboard shortcut as pressed by the
    user in the key mapping's capture mode. Note that internally it uses
    keycodes (and keyvalues) as defined by Gdk, not evdev. It does have the
    ability to import from and export as evdev keycodes, as required by
    libratbagd. See the get_keys() and set_from_evdev() methods."""

    # Gdk uses an offset of 8 from the keycodes defined in linux/input.h as
    # used by evdev.
    _XORG_KEYCODE_OFFSET = 8

    __gsignals__ = {
        'keystroke-set': (GObject.SIGNAL_RUN_FIRST, None, ()),
        'keystroke-cleared': (GObject.SIGNAL_RUN_FIRST, None, ()),
    }

    def __init__(self, **kwargs):
        """Intantiates a new KeyStroke."""
        GObject.Object.__init__(self, **kwargs)
        self._accelerator = ""
        self._keycode = 0
        self._keyval = 0
        self._modifiers = []

    @GObject.Property(type=str)
    def accelerator(self):
        """The accelerator of the current keystroke, as generated by
        Gtk.accelerator_name(keyval, mask)."""
        return self._accelerator

    def process_event(self, event):
        """Processes the given key event to update the current keystroke.

        @param event The event to process, as Gdk.EventKey.
        """
        if not self._check_key(event.hardware_keycode, event.keyval):
            return
        if event.is_modifier:
            if (event.hardware_keycode, event.keyval) not in self._modifiers:
                self._modifiers.append((event.hardware_keycode, event.keyval))
        else:
            self._keycode = event.hardware_keycode
            self._keyval = event.keyval
            # Since keystrokes may only contain a single regular keycode, we
            # accept as soon as the user enters one. TODO: we should assign the
            # modifiers and keycode+keyvalue to self._cur_* so that we can add
            # cancel functionality to the button dialog on Escape.
            self.emit("keystroke-set")
        self._update_accelerator()

    def clear(self):
        """Clears the current keystroke."""
        self._keycode = 0
        self._keyval = 0
        self._modifiers = []
        self._update_accelerator()
        self.emit("keystroke-cleared")

    def set_from_evdev(self, keycode, modifiers):
        """Converts the given evdev keycodes to their Gdk counterparts and sets
        them as the current keystroke.

        @param keycode The evdev keycode, as int.
        @param modifiers A list of modifier keycodes, as [int].
        """
        keycode += self._XORG_KEYCODE_OFFSET
        keyval = self._keycode_to_keyval(keycode)
        if not self._check_key(keycode, keyval):
            return
        self._keycode = keycode
        self._keyval = keyval
        for modifier in modifiers:
            keycode = modifier + self._XORG_KEYCODE_OFFSET
            keyval = self._keycode_to_keyval(keycode)
            if not self._check_key(keycode, keyval):
                continue
            if (keycode, keyval) not in self._modifiers:
                self._modifiers.append((keycode, keyval))
        self._update_accelerator()

    def _keycode_to_keyval(self, keycode):
        # Attempts to retrieve a Gdk keyval belonging to a Gdk keycode. In case
        # none can be found, 0 is returned. Note that there is some inaccuracy
        # here in that the keycode can correspond to several keyvals (due to
        # levels and groups) and that we return the keyval belonging to level
        # and group 0, if any.
        keymap = Gdk.Keymap.get_default()
        ok, keys, keyvals = keymap.get_entries_for_keycode(keycode)
        if ok:
            for key, keyval in zip(keys, keyvals):
                if key.level == 0 and key.group == 0:
                    return keyval
        print("Could not translate keycode to keyval, using 0", file=sys.stderr)
        # This default will be skipped when printing the accelerator, and won't
        # pass self._check_key in which case it will be skipped altogether.
        return 0

    def get_keys(self):
        """Returns a list of keycodes with the first being the pressed key and
        the rest modifiers, if any. These keycodes map to those as defined by
        evdev as opposed to those defined by Gdk, thus the returned list is
        directly usable by libratbag."""
        if self._keycode > self._XORG_KEYCODE_OFFSET:
            ret = [self._keycode - self._XORG_KEYCODE_OFFSET]
        else:
            # TODO: make ratbag reset the key mapping on an empty list or
            # something like that and return that value here instead. Currently
            # this returns an unmappable key.
            ret = [self._keycode]
        return ret + [keycode - self._XORG_KEYCODE_OFFSET for keycode, _ in self._modifiers]

    def _check_key(self, keycode, keyval):
        # Checks if the given keycode and keyval are valid through a simply
        # range check.
        if not self._XORG_KEYCODE_OFFSET <= keycode <= 255:
            print("Keycode is not within the valid range.", file=sys.stderr)
            return False
        elif not Gdk.KEY_space <= keyval <= Gdk.KEY_AudioMicMute:
            print("Keyval is not within the valid range.", file=sys.stderr)
            return False
        return True

    def _update_accelerator(self):
        # Updates the accelerator property, so that any GObject bindings to
        # Gtk.ShortcutLabels' accelerator property are updated automatically.
        mask = Gdk.ModifierType(0)
        for (_, keyval) in self._modifiers:
            # The following are GTK+'s default modifiers that are allowed
            # through in ButtonDialog.on_key_press_event, hence we check for
            # these modifiers only -- it is unlikely we will find others. If
            # this needs to be made more accurate, we can iterate over the mask
            # returned by Gtk.accelerator_get_default_mod_mask().
            # The default mod mask depends on the Gdk backend in use, but will
            # typically include Control, Shift, Alt, Super, Hyper and Meta.
            if keyval == Gdk.KEY_Shift_L or keyval == Gdk.KEY_Shift_R or keyval == Gdk.KEY_Shift_Lock:
                mask |= Gdk.ModifierType.SHIFT_MASK
            elif keyval == Gdk.KEY_Hyper_L or keyval == Gdk.KEY_Hyper_R:
                mask |= Gdk.ModifierType.HYPER_MASK
            elif keyval == Gdk.KEY_Meta_L or keyval == Gdk.KEY_Meta_R:
                mask |= Gdk.ModifierType.META_MASK
            elif keyval == Gdk.KEY_Control_L or keyval == Gdk.KEY_Control_R:
                mask |= Gdk.ModifierType.CONTROL_MASK
            elif keyval == Gdk.KEY_Super_L or keyval == Gdk.KEY_Super_R:
                mask |= Gdk.ModifierType.SUPER_MASK
            elif keyval == Gdk.KEY_Alt_L or keyval == Gdk.KEY_Alt_R:
                mask |= Gdk.ModifierType.MOD1_MASK
        self._accelerator = Gtk.accelerator_name(self._keyval, mask)
        self.notify("accelerator")
